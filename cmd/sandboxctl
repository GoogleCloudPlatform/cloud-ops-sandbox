#!/usr/bin/env python3
#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# -*- coding: utf-8 -*-
# pylint: disable=unnecessary-pass,subprocess-run-check
"""
This is Sandbox CLI to operate Cloud Ops Sandbox.
It supports to create and destroy Cloud Ops Sandbox instances
and to run Sandbox recipes for installed instances.

For information on how to run the CLI, run the following:
`sandboxctl --help`
"""

import json
import os
import subprocess

import click
import yaml


CLI_OS_PATH = os.path.dirname(os.path.abspath(__file__))
LOCAL_CACHE_PATH = "./.sandboxcfg"


# @@@ Private methods
def _run_shell_command(command: str) -> int:
    result = subprocess.run(command, shell=True, bufsize=0)
    return result.returncode


def _shell_command_output(command: str) -> str:
    result = subprocess.run(command, shell=True,
                            bufsize=0, capture_output=True, text=True)
    return result.stdout


def _run_install_script(
        action: str,
        project_id: str = None,
        app_id: str = None,
        billing_acc: str = None,
        verbose_flag: bool = None) -> int:

    command = f'./install.sh {action}'
    if project_id:
        command += f' --project {project_id}'
    # add application id
    if app_id:
        command += f' --app-id {app_id}'
    if billing_acc:
        command += f' --billing-acc {billing_acc}'
    if verbose_flag:
        command += ' --verbose'

    cwd = os.getcwd()
    os.chdir(CLI_OS_PATH)
    try:
        return _run_shell_command(command)
    finally:
        os.chdir(cwd)


def _load_json_from_file(file_path: str) -> dict:
    if os.path.isfile(file_path):
        try:
            f = open(file_path, mode="r", encoding="utf-8")
        except OSError:
            return {}
        with f:
            try:
                return json.load(f)
            except (OSError, json.JSONDecodeError):
                pass  # ignore error and return empty dictionary
    return {}


def _store_json_file(file_path: str, data: dict) -> None:
    try:
        with open(file_path, mode="w", encoding="utf-8") as f:
            json.dump(data, f)
    except OSError:
        pass  # ignore error and return empty dictionary


def _load_yaml_from_file(file_path: str) -> dict:
    if os.path.isfile(file_path):
        try:
            f = open(file_path, mode="r", encoding="utf-8")
        except OSError:
            return {}
        with f:
            try:
                return yaml.safe_load(f)
            except (OSError, yaml.MarkedYAMLError):
                pass  # ignore error and return empty dictionary
    return {}


def _discover_project_id(project_id: str = None) -> str:
    """Acquire Google Cloud project ID if missing"""
    # use cloud shell environment variable
    # (https://cloud.google.com/shell/docs/how-cloud-shell-works)
    if not project_id:
        project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
    if not project_id:
        project_id = _shell_command_output(
            "gcloud config get-value core/project")
    if not project_id or project_id == "(unset)":
        return None
    return project_id


def _read_stored_app_id(project_id: str) -> str:
    """Read application ID local cache or from the project's metadata"""
    cfg = _load_json_from_file(LOCAL_CACHE_PATH)
    if project_id == cfg.get("project-id", "") and cfg.get("app-id", ""):
        return cfg.get("app-id", "")

    command = f'gcloud --quiet compute project-info describe --project="{project_id}"'\
        ' --format="value[](commonInstanceMetadata.items.sandbox-metadata)"'
    metadata = _shell_command_output(command)
    cfg = json.loads(metadata)

    # cache cfg locally for further calls
    _write_sandbox_configuration(
        cfg.get("sandbox-version", ""), project_id, cfg.get("app-id", ""))
    return cfg.get("app-id", "")


def _read_recipe_configuration(app_id: str) -> dict:
    """Read recipes of the application configuration"""
    cfg_path = f'{CLI_OS_PATH}/../apps/{app_id}'
    return _load_yaml_from_file(f'{cfg_path}/recipes.yaml')


def _write_sandbox_configuration(sandbox_version: str, project_id: str, app_id: str) -> None:
    data = {
        "sandbox-version": sandbox_version,
        "project-id": project_id,
        "app-id": app_id
    }
    _store_json_file(LOCAL_CACHE_PATH, data)


def _version_from_file() -> str:
    """Read Sandbox version from file"""
    version_file = f'{CLI_OS_PATH}/../versions.json'
    data = _load_json_from_file(version_file)
    return data.get("version", "<unknown>")


# @@@ Command groups
@ click.group()
@ click.version_option(version=_version_from_file(), prog_name="CloudOps Sandbox CLI")
def cli():
    """Cloud Ops Sandbox CLI to operate Cloud Ops Sandbox.
It supports to create and destroy Cloud Ops Sandbox instances
and to run Sandbox recipes for installed instances.
For information on how to run the CLI, run the following:

sandboxctl --help"""
    pass


@ cli.group()
def recipes():
    """Executes Cloud Ops Sandbox recipes"""
    pass


# @@@ Recipes Commands
@ recipes.command(name="list")
@ click.option('--project', '-p', default=None,
               help='Google Cloud project ID where Sandbox is hosted.')
def recipes_list(project) -> int:
    """List all recipes available for the installed application configuration"""
    project = _discover_project_id(project)
    if not project:
        print("Cannot find project where Sandbox is installed")
        return 1
    app_id = _read_stored_app_id(project)
    if not app_id:
        print(
            f'Cannot discover application configuration of Sandbox in project {project}')
        return 1
    recipes_cfg = _read_recipe_configuration(app_id)
    if recipes_cfg.get("app_id", "") != app_id:
        print("Invalid recipes configuration file")
        return 1

    for idx, recipe in enumerate(recipes_cfg.get("recipes", [])):
        name = recipe.get("name", "noname")
        description = recipe.get("description", "")
        if description:
            print(f'({idx+1}) {name}: {description}')
        else:
            print(f'({idx+1}) {name}')
    return 0


# @@@ CLI Commands
@ cli.command()
@ click.option('--project', '-p', default=None, required=True,
               help='Google Cloud project ID where to install Cloud Ops Sandbox.')
@ click.option('--app-id', '-app', default=None, required=True,
               help="An application ID that identifies the Sandbox configuration.")
# @click.option('--billing_acc', default=None,
#               help="A billing account to use with 'create-all' command to new created GCP project.")
@ click.option('--verbose', '-v', default=False, is_flag=True,
               help='Prints execution trace (same as setting DEBUG environment variable).')
def create(project: str, app_id: str, verbose: bool):
    """Create a new Sandbox installation"""
    return _run_install_script(action="create", project_id=project, app_id=app_id, verbose_flag=verbose)


@ cli.command()
@ click.option('--project', '-p', default=None,
               help='Google Cloud project ID where to install Cloud Ops Sandbox.')
@ click.option('--billing-acc', default=None,
               help="A billing account to use with 'create-all' command to new created GCP project.")
@ click.option('--verbose', '-v', default=False, is_flag=True,
               help='Prints execution trace (same as setting DEBUG environment variable).')
def create_all(project: str, billing_acc: str, verbose: bool) -> int:
    """Deploy Online Boutique with a new Sandbox installation"""
    return _run_install_script(
        action="create-all",
        project_id=project,
        app_id="online-boutique",
        billing_acc=billing_acc,
        verbose_flag=verbose)


@ cli.command()
@ click.option('--project', '-p', default=None, required=True,
               help='Google Cloud project ID where Cloud Ops Sandbox is installed.')
@ click.option('--app-id', '-app', default=None,
               help="An application ID that identifies the Sandbox configuration.")
@ click.option('--verbose', '-v', default=False, is_flag=True,
               help='Prints execution trace (same as setting DEBUG environment variable).')
def destroy(project: str, app_id: str, verbose: bool) -> int:
    """Delete an existing instance of Sandbox"""
    return _run_install_script(action="destroy", project_id=project, app_id=app_id, verbose_flag=verbose)


# @cli.command()
# @click.option('--app-id', '-app', default=None, required=True,
#               help="An application ID that identifies the Sandbox configuration.")
# def validate(app_id):
#     """Delete an existing sandbox"""


if __name__ == '__main__':
    cli()
